{"ast":null,"code":"import \"C:\\\\current_front\\\\node_modules\\\\core-js\\\\modules\\\\es.array.iterator.js\";\nimport \"C:\\\\current_front\\\\node_modules\\\\core-js\\\\modules\\\\es.promise.js\";\nimport \"C:\\\\current_front\\\\node_modules\\\\core-js\\\\modules\\\\es.object.assign.js\";\nimport \"C:\\\\current_front\\\\node_modules\\\\core-js\\\\modules\\\\es.promise.finally.js\";\nimport { createApp } from 'vue';\nimport { createStore } from 'vuex';\nimport { GetUsernameFromCoockies } from '@/assets/get_username_from_cookies.js';\nimport App from './App.vue';\nimport router from './router';\nimport store from '@/store/index.js';\nimport Paginate from \"vuejs-paginate-next\";\nimport \"@/assets/css/table.css\";\nimport vSelect from \"vue-select\";\nimport \"vue-select/dist/vue-select.css\"; // const defaultClientType = 'novoregi'\n// const defaultClientPerPage = 2\n// const store = createStore({\n//     actions: {\n//         async setVariablesFromLocalStorage() {\n//             const SetValuesToRangeFilterInstance = new SetValuesToRangeFilter()\n//             SetValuesToRangeFilterInstance.set()\n//         },\n//         async websocketConnect(ctx) {\n//             let username = new GetUsernameFromCoockies(document.cookie).returnUsername()\n//             let class_model = localStorage.getItem('user_class_model')\n//             if (class_model == null){\n//                 class_model = defaultClientType\n//             }\n//             let url = `ws://localhost:8000/ws/${class_model}/${username}/`\n//             console.log('Starting connection to WebSocket Server')\n//             this.connection = new WebSocket(url)\n//             this.connection.onmessage = function (event) {\n//                 let messageCatch = JSON.parse(event.data)\n//                 let eventName = messageCatch.event\n//                 if (eventName == 'operator_connect') {\n//                     const operator_id = JSON.parse(messageCatch.message).username_id\n//                     document.cookie = `username_id=${operator_id}; secure`\n//                     localStorage.setItem('username_id', operator_id)\n//                     const InstanceSetBankButton = new SetBankButton()\n//                     InstanceSetBankButton.setButtonStatus(messageCatch)\n//                     const InstanceSetClientsModelButton = new SetClientsModelButton()\n//                     InstanceSetClientsModelButton.setButtonStatus(class_model)\n//                     ctx.commit('updateClientsPerPageData', defaultClientPerPage)\n//                 }\n//                 else if (eventName == 'send_non_called_statistics') {\n//                     const statisticsDataMessage = JSON.parse(messageCatch.message).statistics\n//                     ctx.commit('updateStatisticsData', statisticsDataMessage)\n//                 }\n//                 else if (eventName == 'client_mutation') {\n//                     let mutationClient = JSON.parse(messageCatch.message).client\n//                     let mutationClientID = mutationClient.id\n//                     let currentArray = ctx.getters.tableBody\n//                     for (let client of currentArray) {\n//                         if (client.id == mutationClientID) {\n//                             let indexItem = currentArray.findIndex(i => i == client)\n//                             ctx.commit('replaceItemIntoArray', [indexItem, mutationClient])\n//                         }\n//                     }\n//                 }\n//                 else if (eventName == 'headers_mutation') {\n//                     let responseHeaders = JSON.parse(messageCatch.message)\n//                     ctx.commit('updateFirstTableHeaders', responseHeaders.first)\n//                     ctx.commit('updateSecondTableHeaders', responseHeaders.second)\n//                     ctx.commit('updateThirdTableHeaders', responseHeaders.third)\n//                     function callback (data) {\n//                         data.then(responseData => {\n//                             let paginateData = responseData.data.body.paginate_data\n//                             let responseBody = responseData.data.body.body\n//                             let responseAdditionalComments = responseData.data.additional_comments\n//                             let responseClientsTypeForOperators = responseData.data.clients_type_for_operators\n//                             ctx.commit('updateClientsPerPageData', defaultClientPerPage)\n//                             ctx.commit('updatePaginateData', paginateData)\n//                             ctx.commit('updateTableBody', responseBody)\n//                             ctx.commit('updateAdditionalComments', responseAdditionalComments)\n//                             ctx.commit('updateClientsTypeForOperators', responseClientsTypeForOperators)\n//                         })\n//                     }\n//                     const GetDataInstance = new GetData(defaultClientPerPage)\n//                     callback(GetDataInstance.returnSlice())\n//                 }\n//             }\n//             this.connection.onopen = function (event) {\n//                 console.log('Successfully connected to first channel websocket')\n//                 }\n//             function connect_server() {\n//                 let username = new GetUsernameFromCoockies(document.cookie).findUsernameString ()\n//                 let url = `ws://localhost:8000/ws/${class_model}/${username}/`\n//                 console.log('Starting connection to WebSocket Server')\n//                 this.connection = new WebSocket(url);\n//             }\n//             this.connection.onclose = function (event) {\n//                 console.log('Disconnect! Start connection')\n//                 for (var i = 0; i < 3; i++) {\n//                     setTimeout( function timer(){\n//                         let username = new GetUsernameFromCoockies(document.cookie).returnUsername()\n//                         let class_model = localStorage.getItem('user_class_model')\n//                         let url = `ws://localhost:8000/ws/${class_model}/${username}/`\n//                         if (class_model == null){\n//                             class_model = defaultClientType\n//                         }\n//                         console.log('Starting connection to WebSocket Server')\n//                         this.connection = new WebSocket(url);\n//                     }, i*3000 );\n//                 }\n//                 location.reload()\n//             }\n//         },\n//         async getDataDRF(ctx) {\n//             const GetDataInstance = new GetData(defaultClientPerPage)\n//             let responseData = await GetDataInstance.returnSlice()\n//             let paginateData = responseData.data.body.paginate_data\n//             let responseBody = responseData.data.body.body\n//             let responseHeaders = responseData.data.headers\n//             let responseAdditionalComments = responseData.data.additional_comments\n//             let responseClientsTypeForOperators = responseData.data.clients_type_for_operators\n//             ctx.commit('updateClientsPerPageData', defaultClientPerPage)\n//             ctx.commit('updatePaginateData', paginateData)\n//             ctx.commit('updateFirstTableHeaders', responseHeaders.first)\n//             ctx.commit('updateSecondTableHeaders', responseHeaders.second)\n//             ctx.commit('updateThirdTableHeaders', responseHeaders.third)\n//             ctx.commit('updateTableBody', responseBody)\n//             ctx.commit('updateAdditionalComments', responseAdditionalComments)\n//             ctx.commit('updateClientsTypeForOperators', responseClientsTypeForOperators)\n//         },\n//     },\n//     mutations: {\n//         updateFirstTableHeaders (state, firstTableHeadersMessage) {\n//             state.firstTableHeadersArray = firstTableHeadersMessage\n//         },\n//         updateSecondTableHeaders (state, secondTableHeadersMessage) {\n//             state.secondTableHeadersArray = secondTableHeadersMessage\n//         },\n//         updateThirdTableHeaders (state, thirdTableHeadersMessage) {\n//             state.thirdTableHeadersArray = thirdTableHeadersMessage\n//         },\n//         updateTableBody (state, tableBodyMessage) {\n//             state.tableBodyArray = tableBodyMessage\n//         },\n//         replaceItemIntoArray (state, listUpdate) {\n//             state.tableBodyArray[listUpdate[0]] = listUpdate[1]\n//         },\n//         updateAdditionalComments (state, additionalCommentsMessage) {\n//             state.additionalCommentsArray = additionalCommentsMessage\n//         },\n//         updateClientsTypeForOperators (state, clientsTypeForOperatorsMessage) {\n//             state.clientsTypeForOperatorsArray = clientsTypeForOperatorsMessage\n//         },\n//         updateStatisticsData (state, statisticsDataMessage) {\n//             state.statisticsDataArray = statisticsDataMessage\n//         },\n//         updatePaginateData (state, paginateDataMessage) {\n//             state.paginateDataVariable = paginateDataMessage\n//         },\n//         updateClientsPerPageData (state, responseClientsPerPage) {\n//             state.clientsPerPage = responseClientsPerPage\n//         }\n//     },\n//     state: {\n//         firstTableHeadersArray: [],\n//         secondTableHeadersArray: [],\n//         thirdTableHeadersArray: [],\n//         tableBodyArray: [],\n//         additionalCommentsArray: [],\n//         clientsTypeForOperatorsArray: [],\n//         statisticsDataArray: [],\n//         paginateDataVariable: Number(),\n//         clientsPerPage: Number()\n//     },\n//     getters: {\n//         firstTableHeaders(state) {\n//             return state.firstTableHeadersArray\n//         },\n//         secondTableHeaders(state) {\n//             return state.secondTableHeadersArray\n//         },\n//         thirdTableHeaders(state) {\n//             return state.thirdTableHeadersArray\n//         },\n//         tableBody(state) {\n//             return state.tableBodyArray\n//         },\n//         additionalComments(state) {\n//             return state.additionalCommentsArray\n//         },\n//         clientsTypeForOperators(state) {\n//             return state.clientsTypeForOperatorsArray\n//         },\n//         statisticsData(state) {\n//             return state.statisticsDataArray\n//         },\n//         paginateData(state) {\n//             return state.paginateDataVariable\n//         },\n//         clientsPerPageData(state) {\n//             return state.clientsPerPage\n//         }\n//     },\n//     modules: {}\n// })\n\nvar app = createApp(App);\napp.use(vSelect);\napp.use(store);\napp.use(router);\napp.use(Paginate);\napp.mount('#app'); // updateHeaders (state, tableHeadersMessage) {\n//     state.tableHeadersArray = tableHeadersMessage\n// },\n// updateClients (state, tableBodyMessage) {\n//     state.tableBodyArray = tableBodyMessage.sort(function (a, b) {\n//         if (parseFloat(a.scoring_time) > parseFloat(b.scoring_time)) {\n//             return 1;\n//           }\n//           if (parseFloat(a.scoring_time) < parseFloat(b.scoring_time)) {\n//             return -1;\n//           }\n//           return 0;\n//     })\n// },\n// updateDropDownCommentsArray (state, dropDownCommentsMessage) {\n//     state.dropDownCommentsArray = dropDownCommentsMessage\n// },\n// updateDropDownCityAlfabank (state, dropDownCityAlfabank) {\n//     state.dropDownCityAlfabank = dropDownCityAlfabank\n// },\n// else if (JSON.parse(messageCatch.message).headers !== undefined) {\n//     const tableHeadersMessage = JSON.parse(messageCatch.message).headers\n//     const tableBodyMessage = JSON.parse(messageCatch.message).body.body\n//     const additionalCommentsMessage = JSON.parse(messageCatch.message).additional_comments\n//     const clientsTypeForOperatorsMessage = JSON.parse(messageCatch.message).clients_type_for_operators\n//     ctx.commit('updateFirstTableHeaders', tableHeadersMessage.first)\n//     ctx.commit('updateSecondTableHeaders', tableHeadersMessage.second)\n//     ctx.commit('updateThirdTableHeaders', tableHeadersMessage.third)\n//     ctx.commit('updateTableBody', tableBodyMessage)\n//     ctx.commit('updateAdditionalComments', additionalCommentsMessage)\n//     ctx.commit('updateClientsTypeForOperators', clientsTypeForOperatorsMessage)\n// }","map":{"version":3,"sources":["C:/current_front/src/main.js"],"names":["createApp","createStore","GetUsernameFromCoockies","App","router","store","Paginate","vSelect","app","use","mount"],"mappings":";;;;AAAA,SAASA,SAAT,QAA0B,KAA1B;AACA,SAASC,WAAT,QAA4B,MAA5B;AACA,SAASC,uBAAT,QAAwC,uCAAxC;AACA,OAAOC,GAAP,MAAgB,WAAhB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,QAAP,MAAqB,qBAArB;AACA,OAAO,wBAAP;AACA,OAAOC,OAAP,MAAoB,YAApB;AACA,OAAO,gCAAP,C,CAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAGA,IAAMC,GAAG,GAAGR,SAAS,CAACG,GAAD,CAArB;AACAK,GAAG,CAACC,GAAJ,CAAQF,OAAR;AACAC,GAAG,CAACC,GAAJ,CAAQJ,KAAR;AACAG,GAAG,CAACC,GAAJ,CAAQL,MAAR;AACAI,GAAG,CAACC,GAAJ,CAAQH,QAAR;AACAE,GAAG,CAACE,KAAJ,CAAU,MAAV,E,CA6DA;AACQ;AACA;AACR;AACQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEQ;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { createApp } from 'vue'\r\nimport { createStore } from 'vuex'\r\nimport { GetUsernameFromCoockies } from '@/assets/get_username_from_cookies.js'\r\nimport App from './App.vue'\r\nimport router from './router'\r\nimport store from '@/store/index.js'\r\nimport Paginate from \"vuejs-paginate-next\";\r\nimport \"@/assets/css/table.css\"\r\nimport vSelect from \"vue-select\";\r\nimport \"vue-select/dist/vue-select.css\";\r\n\r\n\r\n\r\n// const defaultClientType = 'novoregi'\r\n// const defaultClientPerPage = 2\r\n\r\n\r\n// const store = createStore({\r\n//     actions: {\r\n//         async setVariablesFromLocalStorage() {\r\n//             const SetValuesToRangeFilterInstance = new SetValuesToRangeFilter()\r\n//             SetValuesToRangeFilterInstance.set()\r\n//         },\r\n//         async websocketConnect(ctx) {\r\n//             let username = new GetUsernameFromCoockies(document.cookie).returnUsername()\r\n//             let class_model = localStorage.getItem('user_class_model')\r\n\r\n//             if (class_model == null){\r\n//                 class_model = defaultClientType\r\n//             }\r\n            \r\n//             let url = `ws://localhost:8000/ws/${class_model}/${username}/`\r\n        \r\n//             console.log('Starting connection to WebSocket Server')\r\n//             this.connection = new WebSocket(url)\r\n\r\n\r\n//             this.connection.onmessage = function (event) {\r\n//                 let messageCatch = JSON.parse(event.data)\r\n//                 let eventName = messageCatch.event\r\n\r\n//                 if (eventName == 'operator_connect') {\r\n//                     const operator_id = JSON.parse(messageCatch.message).username_id\r\n\r\n//                     document.cookie = `username_id=${operator_id}; secure`\r\n//                     localStorage.setItem('username_id', operator_id)\r\n\r\n//                     const InstanceSetBankButton = new SetBankButton()\r\n//                     InstanceSetBankButton.setButtonStatus(messageCatch)\r\n\r\n//                     const InstanceSetClientsModelButton = new SetClientsModelButton()\r\n//                     InstanceSetClientsModelButton.setButtonStatus(class_model)\r\n\r\n                    \r\n//                     ctx.commit('updateClientsPerPageData', defaultClientPerPage)\r\n//                 }\r\n//                 else if (eventName == 'send_non_called_statistics') {\r\n//                     const statisticsDataMessage = JSON.parse(messageCatch.message).statistics\r\n//                     ctx.commit('updateStatisticsData', statisticsDataMessage)\r\n//                 }\r\n//                 else if (eventName == 'client_mutation') {\r\n//                     let mutationClient = JSON.parse(messageCatch.message).client\r\n//                     let mutationClientID = mutationClient.id\r\n//                     let currentArray = ctx.getters.tableBody\r\n//                     for (let client of currentArray) {\r\n//                         if (client.id == mutationClientID) {\r\n//                             let indexItem = currentArray.findIndex(i => i == client)\r\n//                             ctx.commit('replaceItemIntoArray', [indexItem, mutationClient])\r\n//                         }\r\n//                     }\r\n//                 }\r\n//                 else if (eventName == 'headers_mutation') {\r\n//                     let responseHeaders = JSON.parse(messageCatch.message)\r\n//                     ctx.commit('updateFirstTableHeaders', responseHeaders.first)\r\n//                     ctx.commit('updateSecondTableHeaders', responseHeaders.second)\r\n//                     ctx.commit('updateThirdTableHeaders', responseHeaders.third)\r\n\r\n//                     function callback (data) {\r\n//                         data.then(responseData => {\r\n//                             let paginateData = responseData.data.body.paginate_data\r\n//                             let responseBody = responseData.data.body.body\r\n//                             let responseAdditionalComments = responseData.data.additional_comments\r\n//                             let responseClientsTypeForOperators = responseData.data.clients_type_for_operators\r\n                            \r\n//                             ctx.commit('updateClientsPerPageData', defaultClientPerPage)\r\n//                             ctx.commit('updatePaginateData', paginateData)\r\n//                             ctx.commit('updateTableBody', responseBody)\r\n//                             ctx.commit('updateAdditionalComments', responseAdditionalComments)\r\n//                             ctx.commit('updateClientsTypeForOperators', responseClientsTypeForOperators)\r\n//                         })\r\n//                     }\r\n//                     const GetDataInstance = new GetData(defaultClientPerPage)\r\n//                     callback(GetDataInstance.returnSlice())\r\n//                 }\r\n//             }\r\n            \r\n//             this.connection.onopen = function (event) {\r\n//                 console.log('Successfully connected to first channel websocket')\r\n//                 }\r\n            \r\n//             function connect_server() {\r\n//                 let username = new GetUsernameFromCoockies(document.cookie).findUsernameString ()\r\n//                 let url = `ws://localhost:8000/ws/${class_model}/${username}/`\r\n//                 console.log('Starting connection to WebSocket Server')\r\n//                 this.connection = new WebSocket(url);\r\n//             }\r\n\r\n//             this.connection.onclose = function (event) {\r\n//                 console.log('Disconnect! Start connection')\r\n//                 for (var i = 0; i < 3; i++) {\r\n//                     setTimeout( function timer(){\r\n//                         let username = new GetUsernameFromCoockies(document.cookie).returnUsername()\r\n//                         let class_model = localStorage.getItem('user_class_model')\r\n//                         let url = `ws://localhost:8000/ws/${class_model}/${username}/`\r\n\r\n//                         if (class_model == null){\r\n//                             class_model = defaultClientType\r\n//                         }\r\n\r\n//                         console.log('Starting connection to WebSocket Server')\r\n//                         this.connection = new WebSocket(url);\r\n//                     }, i*3000 );\r\n//                 }\r\n//                 location.reload()\r\n//             }\r\n//         },\r\n//         async getDataDRF(ctx) {\r\n//             const GetDataInstance = new GetData(defaultClientPerPage)\r\n//             let responseData = await GetDataInstance.returnSlice()\r\n//             let paginateData = responseData.data.body.paginate_data\r\n//             let responseBody = responseData.data.body.body\r\n//             let responseHeaders = responseData.data.headers\r\n//             let responseAdditionalComments = responseData.data.additional_comments\r\n//             let responseClientsTypeForOperators = responseData.data.clients_type_for_operators\r\n            \r\n//             ctx.commit('updateClientsPerPageData', defaultClientPerPage)\r\n//             ctx.commit('updatePaginateData', paginateData)\r\n//             ctx.commit('updateFirstTableHeaders', responseHeaders.first)\r\n//             ctx.commit('updateSecondTableHeaders', responseHeaders.second)\r\n//             ctx.commit('updateThirdTableHeaders', responseHeaders.third)\r\n//             ctx.commit('updateTableBody', responseBody)\r\n//             ctx.commit('updateAdditionalComments', responseAdditionalComments)\r\n//             ctx.commit('updateClientsTypeForOperators', responseClientsTypeForOperators)\r\n//         },\r\n//     },\r\n//     mutations: {\r\n//         updateFirstTableHeaders (state, firstTableHeadersMessage) {\r\n//             state.firstTableHeadersArray = firstTableHeadersMessage\r\n            \r\n//         },\r\n//         updateSecondTableHeaders (state, secondTableHeadersMessage) {\r\n//             state.secondTableHeadersArray = secondTableHeadersMessage\r\n//         },\r\n//         updateThirdTableHeaders (state, thirdTableHeadersMessage) {\r\n//             state.thirdTableHeadersArray = thirdTableHeadersMessage\r\n//         },\r\n\r\n//         updateTableBody (state, tableBodyMessage) {\r\n//             state.tableBodyArray = tableBodyMessage\r\n//         },\r\n//         replaceItemIntoArray (state, listUpdate) {\r\n//             state.tableBodyArray[listUpdate[0]] = listUpdate[1]\r\n//         },\r\n\r\n//         updateAdditionalComments (state, additionalCommentsMessage) {\r\n//             state.additionalCommentsArray = additionalCommentsMessage\r\n//         },\r\n//         updateClientsTypeForOperators (state, clientsTypeForOperatorsMessage) {\r\n//             state.clientsTypeForOperatorsArray = clientsTypeForOperatorsMessage\r\n//         },\r\n\r\n//         updateStatisticsData (state, statisticsDataMessage) {\r\n//             state.statisticsDataArray = statisticsDataMessage\r\n//         },\r\n\r\n//         updatePaginateData (state, paginateDataMessage) {\r\n//             state.paginateDataVariable = paginateDataMessage\r\n//         },\r\n\r\n//         updateClientsPerPageData (state, responseClientsPerPage) {\r\n//             state.clientsPerPage = responseClientsPerPage\r\n//         }\r\n        \r\n//     },\r\n//     state: {\r\n//         firstTableHeadersArray: [],\r\n//         secondTableHeadersArray: [],\r\n//         thirdTableHeadersArray: [],\r\n//         tableBodyArray: [],\r\n//         additionalCommentsArray: [],\r\n//         clientsTypeForOperatorsArray: [],\r\n//         statisticsDataArray: [],\r\n//         paginateDataVariable: Number(),\r\n//         clientsPerPage: Number()\r\n//     },\r\n//     getters: {\r\n//         firstTableHeaders(state) {\r\n//             return state.firstTableHeadersArray\r\n//         },\r\n//         secondTableHeaders(state) {\r\n//             return state.secondTableHeadersArray\r\n//         },\r\n//         thirdTableHeaders(state) {\r\n//             return state.thirdTableHeadersArray\r\n//         },\r\n\r\n//         tableBody(state) {\r\n//             return state.tableBodyArray\r\n//         },\r\n\r\n//         additionalComments(state) {\r\n//             return state.additionalCommentsArray\r\n//         },\r\n//         clientsTypeForOperators(state) {\r\n//             return state.clientsTypeForOperatorsArray\r\n//         },\r\n//         statisticsData(state) {\r\n//             return state.statisticsDataArray\r\n//         },\r\n//         paginateData(state) {\r\n//             return state.paginateDataVariable\r\n//         },\r\n//         clientsPerPageData(state) {\r\n//             return state.clientsPerPage\r\n//         }\r\n\r\n//     },\r\n//     modules: {}\r\n// })\r\n\r\n\r\nconst app = createApp(App);\r\napp.use(vSelect)\r\napp.use(store)\r\napp.use(router)\r\napp.use(Paginate)\r\napp.mount('#app')\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// updateHeaders (state, tableHeadersMessage) {\r\n        //     state.tableHeadersArray = tableHeadersMessage\r\n        // },\r\n// updateClients (state, tableBodyMessage) {\r\n        //     state.tableBodyArray = tableBodyMessage.sort(function (a, b) {\r\n        //         if (parseFloat(a.scoring_time) > parseFloat(b.scoring_time)) {\r\n        //             return 1;\r\n        //           }\r\n        //           if (parseFloat(a.scoring_time) < parseFloat(b.scoring_time)) {\r\n        //             return -1;\r\n        //           }\r\n        //           return 0;\r\n        //     })\r\n        // },\r\n        // updateDropDownCommentsArray (state, dropDownCommentsMessage) {\r\n        //     state.dropDownCommentsArray = dropDownCommentsMessage\r\n        // },\r\n        // updateDropDownCityAlfabank (state, dropDownCityAlfabank) {\r\n        //     state.dropDownCityAlfabank = dropDownCityAlfabank\r\n        // },\r\n        \r\n                // else if (JSON.parse(messageCatch.message).headers !== undefined) {\r\n                //     const tableHeadersMessage = JSON.parse(messageCatch.message).headers\r\n                //     const tableBodyMessage = JSON.parse(messageCatch.message).body.body\r\n                //     const additionalCommentsMessage = JSON.parse(messageCatch.message).additional_comments\r\n                //     const clientsTypeForOperatorsMessage = JSON.parse(messageCatch.message).clients_type_for_operators\r\n\r\n                //     ctx.commit('updateFirstTableHeaders', tableHeadersMessage.first)\r\n                //     ctx.commit('updateSecondTableHeaders', tableHeadersMessage.second)\r\n                //     ctx.commit('updateThirdTableHeaders', tableHeadersMessage.third)\r\n                //     ctx.commit('updateTableBody', tableBodyMessage)\r\n                //     ctx.commit('updateAdditionalComments', additionalCommentsMessage)\r\n                //     ctx.commit('updateClientsTypeForOperators', clientsTypeForOperatorsMessage)\r\n                // }"]},"metadata":{},"sourceType":"module"}